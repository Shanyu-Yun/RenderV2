## 一、先看你当前的 VkResource 做了什么

当前版本核心功能：VkResource

- 持有 `VmaAllocator m_allocator`，在 `initialize(VkContext&)` 里创建，在析构或 `cleanup()` 里销毁
- 封装了：
  - `createBuffer / destroyBuffer`
  - `createImage / destroyImage`
  - `mapMemory / unmapMemory`
- buffer / image 用简单的 `BufferHandle` / `ImageHandle` 结构包住 `{ VkBuffer/VkImage + VmaAllocation }`

存在几个明显不足（正好为扩展提供空间）：

1. `createBuffer` 的签名太底层：

   ```
   BufferHandle createBuffer(
       VkDeviceSize size,
       VkBufferUsageFlags usage,
       VmaMemoryUsage memoryUsage,
       VkMemoryPropertyFlags // 参数完全没用到
   );
   ```

   - 不直观，不区分 “顶点缓冲 / 索引缓冲 / uniform / staging / readback / storage” 等语义
   - `VkMemoryPropertyFlags` 参数未使用，容易产生误导

2. `createImage` 直接要求传 `VkImageCreateInfo`，对调用者不友好

3. 销毁完全靠调用者记住 `destroyBuffer/destroyImage`

4. 没有 image view、sampler、数据上传、layout transition 等高级封装

------

## 二、第一步：用描述结构体抽象 Buffer / Image 用途

目标：调用端能写出语义化的代码，例如：

```
auto vertexBuffer = res.createBuffer({
    .size = vbSize,
    .usage = BufferUsage::Vertex | BufferUsage::TransferDst,
    .memory = MemoryUsage::GpuOnly,
    .debugName = "MeshVertexBuffer"
});
```

而不是到处重复 Vulkan Flag。

### 2.1 设计通用的 Buffer 描述

```
enum class BufferUsageFlags : uint32_t {
    None        = 0,
    Vertex      = 1 << 0,
    Index       = 1 << 1,
    Uniform     = 1 << 2,
    Storage     = 1 << 3,
    StagingSrc  = 1 << 4, // Host→Device
    StagingDst  = 1 << 5, // Device→Host
    Indirect    = 1 << 6,
};

inline BufferUsageFlags operator|(BufferUsageFlags a, BufferUsageFlags b) {
    return static_cast<BufferUsageFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class MemoryUsage {
    GpuOnly,
    CpuToGpu,
    GpuToCpu
};

struct BufferDesc {
    VkDeviceSize     size = 0;
    BufferUsageFlags usage = BufferUsageFlags::None;
    MemoryUsage      memory = MemoryUsage::GpuOnly;
    const char*      debugName = nullptr;
};
```

然后在 `VkResource` 内部做统一转换：

```
class VkResource {
public:
    BufferHandle createBuffer(const BufferDesc& desc);
    void         destroyBuffer(BufferHandle& handle);

    // 不要兼容旧接口
    ...
};
```

`createBuffer()` 内把 enum 转成 Vulkan Flag：

```
VkBufferUsageFlags VkResource::toVkUsage(BufferUsageFlags usage)
{
    VkBufferUsageFlags flags = 0;
    if (usage & BufferUsageFlags::Vertex)     flags |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    if (usage & BufferUsageFlags::Index)      flags |= VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    if (usage & BufferUsageFlags::Uniform)    flags |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    if (usage & BufferUsageFlags::Storage)    flags |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
    if (usage & BufferUsageFlags::StagingSrc) flags |= VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
    if (usage & BufferUsageFlags::StagingDst) flags |= VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    if (usage & BufferUsageFlags::Indirect)   flags |= VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
    return flags;
}

VmaMemoryUsage VkResource::toVmaUsage(MemoryUsage mem)
{
    switch (mem) {
    case MemoryUsage::GpuOnly:  return VMA_MEMORY_USAGE_GPU_ONLY;
    case MemoryUsage::CpuToGpu: return VMA_MEMORY_USAGE_CPU_TO_GPU;
    case MemoryUsage::GpuToCpu: return VMA_MEMORY_USAGE_GPU_TO_CPU;
    }
    return VMA_MEMORY_USAGE_UNKNOWN;
}
```

这样，你后续想增加新的用途（比如 RayTracing AS）也只改一处映射即可。

------

### 2.2 Image 描述同理

```
enum class ImageUsageFlags : uint32_t {
    None        = 0,
    ColorRT     = 1 << 0,
    DepthStencil= 1 << 1,
    Sampled     = 1 << 2,
    Storage     = 1 << 3,
    TransferSrc = 1 << 4,
    TransferDst = 1 << 5,
};

struct ImageDesc {
    uint32_t           width = 1;
    uint32_t           height = 1;
    uint32_t           depth = 1;
    uint32_t           mipLevels = 1;
    uint32_t           arrayLayers = 1;
    VkFormat           format = VK_FORMAT_UNDEFINED;
    VkSampleCountFlagBits samples = VK_SAMPLE_COUNT_1_BIT;
    ImageUsageFlags    usage = ImageUsageFlags::ColorRT | ImageUsageFlags::Sampled;
    MemoryUsage        memory = MemoryUsage::GpuOnly;
    VkImageTiling      tiling = VK_IMAGE_TILING_OPTIMAL;
    VkImageType        type = VK_IMAGE_TYPE_2D;
    VkImageCreateFlags flags = 0;
    const char*        debugName = nullptr;
};
```

内部构造 `VkImageCreateInfo` 并调用 VMA：

```
ImageHandle VkResource::createImage(const ImageDesc& desc)
{
    VkImageCreateInfo imgInfo{};
    imgInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imgInfo.imageType = desc.type;
    imgInfo.extent = { desc.width, desc.height, desc.depth };
    imgInfo.mipLevels = desc.mipLevels;
    imgInfo.arrayLayers = desc.arrayLayers;
    imgInfo.format = desc.format;
    imgInfo.tiling = desc.tiling;
    imgInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    imgInfo.usage = toVkUsage(desc.usage);   // 自己映射
    imgInfo.samples = desc.samples;
    imgInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    imgInfo.flags = desc.flags;

    return createImage(imgInfo, toVmaUsage(desc.memory));
}
```

> 这样你在调用端只用考虑 “我要创建一个什么用途的 image/buffer”，不用反复记 Flag 组合。

------

## 三、第二步：增加 ImageView / Sampler / 常用封装

为了真正“方便管理资源”，你至少还需要：

- `createImageView` / `destroyImageView`
- 可选：`createSampler` / `destroySampler`
- 绑定 debug name（`vkSetDebugUtilsObjectNameEXT` 或 VMA 的 `vmaSetAllocationName`）

示例接口：

```
struct ImageViewHandle {
    VkImageView view = VK_NULL_HANDLE;
    VkImage     image = VK_NULL_HANDLE; // 可选
};

ImageViewHandle createImageView(VkImage image,
                                VkFormat format,
                                VkImageAspectFlags aspectMask,
                                const char* debugName = nullptr);

void destroyImageView(ImageViewHandle& handle);
```

甚至可以做成基于 `ImageHandle` 的快捷函数：

```
ImageViewHandle createImageView(const ImageHandle& img,
                                VkFormat format,
                                VkImageAspectFlags aspectMask,
                                const char* debugName = nullptr);
```

------

## 四、第三步：提供上传数据的高层接口

目前你只提供了裸 `map/unmap`；这意味着每次上传数据都要在调用端写模板代码。建议增加：

```
// 对小块、HostVisible Buffer 的简单 memset 上传
void uploadToBuffer(const BufferHandle& handle, const void* data, size_t size, size_t offset = 0);

// 模板封装
template<typename T>
void uploadToBuffer(const BufferHandle& handle, const T& obj, size_t offset = 0) {
    uploadToBuffer(handle, &obj, sizeof(T), offset);
}
```

实现参考：

```
void VkResource::uploadToBuffer(const BufferHandle& handle, const void* data, size_t size, size_t offset)
{
    void* dst = nullptr;
    if (vmaMapMemory(m_allocator, handle.allocation, &dst) != VK_SUCCESS)
        throw std::runtime_error("vmaMapMemory failed");

    std::memcpy(static_cast<char*>(dst) + offset, data, size);
    vmaUnmapMemory(m_allocator, handle.allocation);
}
```

对于 GPU-only Buffer，则可以再封装一层 “创建 staging buffer + 复制 + pipeline barrier” 的 helper，这部分需要配合 `VkContext` 的 command buffer / queue 工具，我就只描述设计思路：

```
BufferHandle createAndUploadGpuBuffer(
    VkContext& ctx,
    VkResource& res,
    const void* data,
    VkDeviceSize size,
    BufferUsageFlags usage,
    const char* debugName);
```

内部步骤：

1. 创建 staging buffer（CPU_TO_GPU, TRANSFER_SRC）
2. `uploadToBuffer` 填数据
3. 使用临时 command buffer：
   - `vkCmdCopyBuffer(staging → gpu)`
   - 可选：添加适当的 buffer memory barrier
4. 提交 + 等待完成
5. 销毁 staging buffer

------

## 五、第四步：用 RAII 封装资源生命周期（可选但强烈推荐）

当前：

- `createBuffer` 返回 `BufferHandle`
- 调用者必须记得在合适时间 hand-call `destroyBuffer()`

容易出错。可以增加一个简单 RAII 包装类型，让资源析构时自动归还给 `VkResource`：

```
class ManagedBuffer {
public:
    ManagedBuffer() = default;
    ManagedBuffer(VkResource* owner, BufferHandle handle)
        : m_owner(owner), m_handle(handle) {}
    ManagedBuffer(const ManagedBuffer&) = delete;
    ManagedBuffer& operator=(const ManagedBuffer&) = delete;
    ManagedBuffer(ManagedBuffer&& other) noexcept { *this = std::move(other); }
    ManagedBuffer& operator=(ManagedBuffer&& other) noexcept {
        if (this != &other) {
            release();
            m_owner = other.m_owner;
            m_handle = other.m_handle;
            other.m_owner = nullptr;
            other.m_handle = {};
        }
        return *this;
    }
    ~ManagedBuffer() { release(); }

    const BufferHandle& get() const { return m_handle; }
    BufferHandle&       get()       { return m_handle; }

private:
    void release() {
        if (m_owner && m_handle.buffer) {
            m_owner->destroyBuffer(m_handle);
        }
    }

    VkResource*  m_owner = nullptr;
    BufferHandle m_handle{};
};
```

然后在 `VkResource` 提供：

```
ManagedBuffer createManagedBuffer(const BufferDesc& desc) {
    return ManagedBuffer(this, createBuffer(desc));
}
```

Image 同理 `ManagedImage`。这样：

- 上层代码只要把 `ManagedBuffer` / `ManagedImage` 当普通对象用
- 离开作用域自动释放资源
- 管理大批资源更安全